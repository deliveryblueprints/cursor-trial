<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gayatri's Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 40px;
        }

        .game-container {
            background: #4A148C;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 1200px;
            width: 100%;
        }

        .game-header {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .game-header h1 {
            margin: 0;
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .game-info {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
            flex: 1;
            justify-content: center;
        }

        .level-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-shrink: 0;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 30px;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }



        .score, .high-score, .level-display, .player-welcome, .food-debug {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        canvas {
            border: 4px solid #333;
            border-radius: 15px;
            background: #4A148C;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
            margin: 20px 0;
        }

        .controls {
            margin-top: 20px;
            color: #ffffff;
            font-size: 1.1em;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over h2 {
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .restart-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 15px;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }

        .start-screen {
            margin-top: 20px;
            text-align: center;
        }

        .start-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 1.3em;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .start-btn:hover {
            transform: scale(1.05);
        }

        /* Player Input Styles */
        .player-input-section {
            margin: 0;
            text-align: left;
        }

        .input-group {
            margin: 0;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group label {
            display: inline;
            margin: 0;
            color: white;
            font-weight: bold;
            text-align: left;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .input-group input {
            width: 120px;
            padding: 6px 10px;
            border: 2px solid #ddd;
            border-radius: 15px;
            font-size: 0.9em;
            transition: border-color 0.3s;
            box-sizing: border-box;
            margin: 0;
            display: inline-block;
            background: white;
            color: #333;
        }

        .input-group input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.1);
        }





        .level-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 10px 0;
        }

        .level-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 100px;
        }

        .level-btn.beginner {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }

        .level-btn.intermediate {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .level-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .level-info {
            margin-top: 20px;
            color: white;
            font-size: 0.9em;
        }

        .level-info p {
            margin: 5px 0;
        }

        .level-info strong {
            color: #4ecdc4;
        }

        /* Live Score Card Styles */
        .live-score-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .live-score-card h3 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3em;
        }

        .score-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
            border-left: 4px solid #4ecdc4;
            transition: transform 0.2s;
        }

        .score-item:hover {
            transform: translateX(5px);
        }

        .score-item.current-player {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border-left-color: #2c7a7b;
        }

        .score-item.rank-1 {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            border-left-color: #b8860b;
        }

        .score-item.rank-2 {
            background: linear-gradient(45deg, #c0c0c0, #e5e5e5);
            color: #333;
            border-left-color: #808080;
        }

        .score-item.rank-3 {
            background: linear-gradient(45deg, #cd7f32, #daa520);
            color: white;
            border-left-color: #8b4513;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-rank {
            font-weight: bold;
            font-size: 1.1em;
            min-width: 30px;
        }

        .player-name {
            font-weight: 600;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .player-score {
            font-weight: bold;
            font-size: 1.1em;
        }

        .score-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .player-count {
            color: #666;
            font-size: 0.9em;
        }

        .refresh-scores-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: transform 0.2s;
        }

        .refresh-scores-btn:hover {
            transform: scale(1.05);
        }

        .loading-scores {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        .no-scores {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        .mobile-controls {
            display: none;
            margin-top: 20px;
        }

        .mobile-controls button {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid #333;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            margin: 5px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mobile-controls button:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
                max-width: 95%;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .mobile-controls {
                display: block;
            }
            
            canvas {
                width: 100%;
                height: auto;
                max-width: 400px;
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Start Screen at the Top -->
        <div class="start-screen" id="startScreen">
            <h3 style="font-size: 1.5em; margin-bottom: 20px; color: white;">üêç Gayatri's Snake Game</h3>
            
            <div class="level-info">
                <p><strong>Beginner:</strong> Slower speed, easier to control</p>
                <p><strong>Intermediate:</strong> Current speed, challenging gameplay</p>
            </div>
        </div>
        
        <div class="game-header">
            <div class="game-info">
                <!-- Player Name Input -->
                <div class="player-input-section">
                    <div class="input-group">
                        <label for="playerName">Name:</label>
                        <input type="text" id="playerName" placeholder="Your name" maxlength="20">
                    </div>
                </div>
                <div class="player-welcome" id="playerWelcome" style="display: none;">
                    Welcome, <span id="welcomeUser">Player</span>!
                </div>
                <div class="score">Score: <span id="score">0</span></div>
                <div class="level-display" id="levelDisplay" style="display: none;">Level: <span id="currentLevel">-</span></div>
                <div class="high-score">High Score: <span id="highScore">0</span></div>
                <div class="food-debug" id="foodDebug" style="display: none;">Food: <span id="foodCoords">-</span> | Grid: <span id="gridInfo">-</span></div>
            </div>
                    <div class="level-buttons">
            <button class="level-btn beginner" onclick="startGame('beginner')">üê£ Beginner</button>
            <button class="level-btn intermediate" onclick="startGame('intermediate')">‚ö° Intermediate</button>
            <button class="level-btn" onclick="toggleDebugGrid()" style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">üîç Debug Grid</button>
        </div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="controls" id="controls" style="display: none;">
            <p>Use arrow keys to move the snake</p>
            <p>Catch the mouse to grow and score points!</p>
        </div>
        <div class="mobile-controls" id="mobileControls" style="display: none;">
            <button onclick="changeDirection('ArrowUp')">‚¨ÜÔ∏è</button>
            <div>
                <button onclick="changeDirection('ArrowLeft')">‚¨ÖÔ∏è</button>
                <button onclick="changeDirection('ArrowRight')">‚û°Ô∏è</button>
            </div>
            <button onclick="changeDirection('ArrowDown')">‚¨áÔ∏è</button>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>
    
    <!-- Live Score Card at the Bottom -->
    <div class="live-score-card" id="liveScoreCard">
        <h3>üèÜ Live Leaderboard</h3>
        <div class="score-list" id="scoreList">
            <div class="loading-scores">Loading scores...</div>
        </div>
        <div class="score-card-footer">
            <span class="player-count" id="playerCount">0 players online</span>
            <button class="refresh-scores-btn" onclick="refreshLiveScores()">üîÑ Refresh</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');

        const gridSize = 25;
        let tileCount = 32; // Fixed tile count for 800x600 canvas (800/25 = 32, 600/25 = 24)

        let snake = [
            {x: 10, y: 10}
        ];
        let food = {x: 15, y: 15}; // Initialize food with default position
        let dx = 0; // No movement until game starts
        let dy = 0;
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameRunning = false; // Game doesn't start automatically
        let gameSpeed = 150; // Default speed (intermediate)
        let currentLevel = '';
        let gameInterval = null; // Global game loop interval
        let lastFoodTime = Date.now(); // Track when food was last valid
        let foodMissingThreshold = 3000; // 3 seconds threshold for missing food

        highScoreElement.textContent = highScore;

        function generateFood() {
            console.log('=== GENERATE FOOD START ===');
            console.log('Snake length:', snake.length);
            console.log('Snake positions:', snake.map(s => `(${s.x},${s.y})`));
            
            // Fixed grid dimensions for 800x600 canvas - NEVER CHANGE THESE
            const maxX = 32; // 800/25 = 32 tiles horizontally
            const maxY = 24; // 600/25 = 24 tiles vertically
            
            console.log('Using fixed grid bounds:', maxX, 'x', maxY);
            
            // Check if snake fills entire board (impossible to place food)
            if (snake.length >= maxX * maxY) {
                console.log('CRITICAL: Snake fills entire board!');
                return;
            }
            
            let attempts = 0;
            const maxAttempts = 200; // Increased attempts for longer snakes
            let newFood;
            
            // First, try random placement within valid bounds
            do {
                newFood = {
                    x: Math.floor(Math.random() * maxX),
                    y: Math.floor(Math.random() * maxY)
                };
                attempts++;
                
                // Check if food spawns on snake
                let onSnake = false;
                for (let segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        onSnake = true;
                        break;
                    }
                }
                
                if (!onSnake) {
                    food = newFood;
                    console.log('‚úÖ Random placement successful at:', food.x, food.y);
                    break;
                }
            } while (attempts < maxAttempts);
            
            // If random placement failed, use systematic search
            if (!food || typeof food.x !== 'number') {
                console.log('Random placement failed, using systematic search...');
                
                // Create a grid of available positions within valid bounds
                let availablePositions = [];
                for (let x = 0; x < maxX; x++) {
                    for (let y = 0; y < maxY; y++) {
                        let available = true;
                        for (let segment of snake) {
                            if (segment.x === x && segment.y === y) {
                                available = false;
                                break;
                            }
                        }
                        if (available) {
                            availablePositions.push({x: x, y: y});
                        }
                    }
                }
                
                console.log('Available positions found:', availablePositions.length);
                
                if (availablePositions.length > 0) {
                    // Pick a random available position
                    const randomIndex = Math.floor(Math.random() * availablePositions.length);
                    food = availablePositions[randomIndex];
                    console.log('‚úÖ Systematic placement successful at:', food.x, food.y);
                } else {
                    console.log('‚ùå No available positions found!');
                    // This should never happen, but just in case
                    food = {x: 0, y: 0};
                }
            }
            
            // Final validation
            if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
                console.log('CRITICAL: Food object still invalid after all attempts!');
                food = {x: 10, y: 10}; // Emergency fallback
            }
            
            // Verify food is not on snake
            let finalCheck = false;
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    finalCheck = true;
                    console.log('üö® FINAL CHECK FAILED: Food on snake! Regenerating...');
                    break;
                }
            }
            
            if (finalCheck) {
                console.log('Regenerating food due to final check failure...');
                // Try one more time with a different approach within valid bounds
                for (let x = 0; x < maxX; x++) {
                    for (let y = 0; y < maxY; y++) {
                        let safe = true;
                        for (let seg of snake) {
                            if (seg.x === x && seg.y === y) {
                                safe = false;
                                break;
                            }
                        }
                        if (safe) {
                            food = {x: x, y: y};
                            console.log('‚úÖ Emergency placement at:', x, y);
                            break;
                        }
                    }
                    if (food && food.x === x) break;
                }
            }
            
            console.log('=== GENERATE FOOD END ===');
            console.log('Final food position:', food.x, food.y);
            console.log('Food object validity:', food && typeof food.x === 'number' && typeof food.y === 'number');
            console.log('Snake collision check:', snake.some(s => s.x === food.x && s.y === food.y));
            
            // Reset the food timer since we just generated valid food
            lastFoodTime = Date.now();
            
            return food; // Explicitly return the food object
        }

        function drawGame() {
            try {
                // FOOD DEBUGGING: Check food state before drawing
                console.log('=== FOOD DEBUG START ===');
                console.log('Food object:', food);
                console.log('Food type:', typeof food);
                console.log('Food coordinates:', food?.x, food?.y);
                console.log('Food validity:', food && typeof food.x === 'number' && typeof food.y === 'number');
                
                // If food is invalid, regenerate it immediately
                if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
                    console.log('üö® FOOD IS INVALID - REGENERATING IMMEDIATELY');
                    generateFood();
                    console.log('Food regenerated:', food);
                }
                
                // Clear canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            
                // Debug: Draw food position indicator and grid bounds at top of canvas
                // Save current context to prevent interference from other drawing operations
                ctx.save();
                
                // Draw background for better text visibility
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(5, 5, 350, 50);
                
                // Draw border around debug info
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(5, 5, 350, 50);
                
                // Set text properties for debug overlay
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                
                // Draw main debug info
                ctx.fillText(`Canvas: 800x600 | Grid: 25x25 | Tiles: 32x24`, 10, 20);
                
                if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                    ctx.fillText(`Food at: (${food.x}, ${food.y}) | Canvas pos: (${food.x * 25}, ${food.y * 25})`, 10, 40);
                    
                    // Draw a small red dot at the food's grid position for visual reference
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(food.x * 25, food.y * 25, 3, 3);
                    console.log('Debug: Drew food position indicator and grid reference');
                }
                
                // Restore context to prevent interference with other drawing operations
                ctx.restore();
            
            // Draw debug grid to visualize tile boundaries
            drawDebugGrid();

            // Draw snake body as connected segments with gradient effect
            ctx.lineWidth = 4;
            
            // Draw body segments with connecting lines and gradient
            for (let i = 1; i < snake.length; i++) {
                // Create gradient effect - newer segments are brighter
                const brightness = Math.max(0.4, 1 - (i / snake.length));
                const r = Math.floor(78 * brightness); // 78 is the red component of #4ecdc4
                const g = Math.floor(205 * brightness); // 205 is the green component
                const b = Math.floor(196 * brightness); // 196 is the blue component
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                
                // Draw the body segment with rounded corners
                const x = snake[i].x * gridSize;
                const y = snake[i].y * gridSize;
                const size = gridSize - 1;
                const radius = 6;
                
                // Add subtle glow effect
                ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Use a simpler rounded rectangle approach
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + size - radius, y);
                ctx.quadraticCurveTo(x + size, y, x + size, y + radius);
                ctx.lineTo(x + size, y + size - radius);
                ctx.quadraticCurveTo(x + size, y + size, x + size - radius, y + size);
                ctx.lineTo(x + radius, y + size);
                ctx.quadraticCurveTo(x, y + size, x, y + size - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
                
                // Reset shadow for connecting lines
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Draw connecting line to next segment (if there is one)
                if (i < snake.length - 1) {
                    const current = snake[i];
                    const next = snake[i + 1];
                    
                    // Calculate center points
                    const currentCenterX = current.x * gridSize + gridSize / 2;
                    const currentCenterY = current.y * gridSize + gridSize / 2;
                    const nextCenterX = next.x * gridSize + gridSize / 2;
                    const nextCenterY = next.y * gridSize + gridSize / 2;
                    
                    // Draw thicker, more visible connecting line
                    ctx.strokeStyle = `rgba(44, 62, 80, ${brightness + 0.3})`;
                    ctx.lineWidth = Math.max(3, 5 * brightness);
                    ctx.beginPath();
                    ctx.moveTo(currentCenterX, currentCenterY);
                    ctx.lineTo(nextCenterX, nextCenterY);
                    ctx.stroke();
                }
            }

            // Draw snake head (üêç emoji)
            ctx.font = `${gridSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üêç', snake[0].x * gridSize + gridSize/2, snake[0].y * gridSize + gridSize/2);

            // Draw food (üê≠ mouse emoji) - only if food has valid coordinates
            console.log('=== DRAWING FOOD SECTION ===');
            console.log('About to draw food. Food object:', food);
            console.log('Food coordinates:', food?.x, food?.y);
            console.log('Grid size:', gridSize);
            console.log('Canvas position calculation:', food ? `${food.x * gridSize + gridSize/2}, ${food.y * gridSize + gridSize/2}` : 'N/A');
            
            if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                console.log('‚úÖ Food is valid, drawing now...');
                
                // Calculate exact canvas positions
                const foodX = food.x * gridSize;
                const foodY = food.y * gridSize;
                const foodCenterX = foodX + gridSize/2;
                const foodCenterY = foodY + gridSize/2;
                
                console.log('Food canvas positions - X:', foodX, 'Y:', foodY, 'Center X:', foodCenterX, 'Center Y:', foodCenterY);
                
                // Validate food position is within canvas bounds
                if (foodX >= 0 && foodX < canvas.width && foodY >= 0 && foodY < canvas.height) {
                    console.log('‚úÖ Food position is within canvas bounds');
                    
                    // Draw a bright background circle first to ensure visibility
                    ctx.fillStyle = '#ffff00'; // Bright yellow background
                    ctx.beginPath();
                    ctx.arc(foodCenterX, foodCenterY, gridSize/2, 0, 2 * Math.PI);
                    ctx.fill();
                    console.log('‚úÖ Yellow background circle drawn');
                    
                    // Set text color to ensure visibility
                    ctx.fillStyle = '#000000'; // Black text on yellow background
                    ctx.font = `${gridSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üê≠', foodCenterX, foodCenterY);
                    console.log('‚úÖ Food emoji drawn successfully');
                    
                    // Draw a bright red border around the food for maximum visibility
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(foodX, foodY, gridSize, gridSize);
                    console.log('‚úÖ Red border drawn around food');
                    
                    // Draw a bright green dot in the center as additional backup
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(foodCenterX, foodCenterY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    console.log('‚úÖ Green center dot drawn');
                    
                } else {
                    console.log('‚ùå FOOD POSITION OUTSIDE CANVAS BOUNDS!');
                    console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                    console.log('Food would be at:', foodX, foodY);
                    console.log('Regenerating food...');
                    generateFood();
                }
                
            } else {
                console.log('‚ùå FOOD IS INVALID - CANNOT DRAW');
                console.log('Food type:', typeof food);
                console.log('Food value:', food);
                console.log('This should not happen after our validation above!');
            }
            
            // Update food debug display
            updateFoodDebug();
        } catch (error) {
            console.error('Error in drawGame:', error);
        }
        }

        function moveSnake() {
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};

            // Check wall collision with fixed bounds
            const maxX = 32; // 800/25 = 32 tiles horizontally
            const maxY = 24; // 600/25 = 24 tiles vertically
            if (head.x < 0 || head.x >= maxX || head.y < 0 || head.y >= maxY) {
                gameOver();
                return;
            }

            // Check self collision
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    gameOver();
                    return;
                }
            }

            // Check food collision BEFORE moving the snake
            let foodEaten = false;
            if (food && typeof food.x === 'number' && typeof food.y === 'number' && head.x === food.x && head.y === food.y) {
                console.log('Food collision detected! Head at:', head.x, head.y, 'Food at:', food.x, food.y);
                score += 10;
                scoreElement.textContent = score;
                console.log('Score increased to:', score);
                foodEaten = true;
                
                // Update live scoreboard immediately when score increases
                if (currentPlayerId) {
                    updatePlayerScore(currentPlayerId, score, currentLevel);
                }
            }
            
            // Move the snake
            snake.unshift(head);
            
            // Generate new food if food was eaten
            if (foodEaten) {
                console.log('üîÑ Regenerating food after eating...');
                generateFood();
                
                // Verify new food was generated properly
                if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                    console.log('‚úÖ New food generated successfully at:', food.x, food.y);
                    
                    // Double-check food is not on snake
                    let foodOnSnake = false;
                    for (let segment of snake) {
                        if (segment.x === food.x && segment.y === food.y) {
                            foodOnSnake = true;
                            console.log('üö® New food spawned on snake! Regenerating again...');
                            break;
                        }
                    }
                    
                    if (foodOnSnake) {
                        console.log('Regenerating food again due to snake collision...');
                        generateFood();
                        console.log('Second attempt food at:', food.x, food.y);
                    }
                } else {
                    console.log('‚ùå Food generation failed! Food object:', food);
                    // Emergency food generation
                    food = {x: 15, y: 15};
                    generateFood();
                }
            } else {
                snake.pop();
            }
        }

        function gameOver() {
            gameRunning = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreElement.textContent = highScore;
            }
            finalScoreElement.textContent = score;
            gameOverElement.style.display = 'block';
            
            // Remove player from live scoreboard when game ends
            if (currentPlayerId) {
                removePlayerFromLiveScoreboard(currentPlayerId);
                currentPlayerId = null;
            }
        }

        function startGame(level) {
            // Validate player name before starting
            if (!validatePlayerName()) {
                return;
            }
            
            currentLevel = level;
            
            // Set game speed based on level
            if (level === 'beginner') {
                gameSpeed = 250; // Slower speed for beginners
            } else if (level === 'intermediate') {
                gameSpeed = 150; // Current speed
            }
            
            snake = [{x: 10, y: 10}];
            dx = 1; // Start moving right
            dy = 0;
            score = 0;
            scoreElement.textContent = score;
            gameRunning = true;
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('levelDisplay').style.display = 'block';
            document.getElementById('currentLevel').textContent = level.charAt(0).toUpperCase() + level.slice(1);
            
            // Store the player name and show welcome message
            const playerName = getPlayerName();
            localStorage.setItem('snakePlayerName', playerName);
            document.getElementById('welcomeUser').textContent = playerName;
            document.getElementById('playerWelcome').style.display = 'block';
            
            // Add player to live scoreboard
            addPlayerToLiveScoreboard(playerName);
            
            // Use fixed tile count for consistent gameplay
            tileCount = 32; // Fixed value for 800x600 canvas
            console.log('Game started with tile count:', tileCount);
            
            // Generate food and ensure it's visible
            generateFood();
            console.log('Game started! Food at:', food.x, food.y);
            console.log('Snake starting position:', snake[0].x, snake[0].y);
            
            // Force immediate food visibility check
            if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                console.log('Food is valid, coordinates:', food.x, food.y);
                console.log('Food canvas position:', food.x * gridSize, food.y * gridSize);
            } else {
                console.log('ERROR: Food is invalid after generation!');
            }
            
            // Double-check that food is not on snake
            if (food.x === snake[0].x && food.y === snake[0].y) {
                console.log('Warning: Food spawned on snake! Regenerating...');
                generateFood();
                console.log('New food position:', food.x, food.y);
            }
            
            // Final safety check - ensure food object is valid
            if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
                console.log('CRITICAL: Food object invalid after generation, creating emergency food');
                food = {x: 15, y: 15}; // Emergency fallback
                generateFood(); // Try one more time
            }
            
                        // Draw the game state immediately to show the food
            drawGame();
            
            // Show food debug info
            document.getElementById('foodDebug').style.display = 'block';
            updateFoodDebug();
            
            // Restart the game loop with new speed
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            // Small delay to ensure food is visible before game loop starts
            setTimeout(() => {
                gameInterval = setInterval(gameLoop, gameSpeed);
                console.log('Game loop restarted with speed:', gameSpeed, 'ms for level:', level);
            }, 100);
        }

        function restartGame() {
            snake = [{x: 10, y: 10}];
            dx = 0; // Stop movement
            dy = 0;
            score = 0;
            scoreElement.textContent = score;
            gameRunning = false;
            currentLevel = '';
            gameOverElement.style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('mobileControls').style.display = 'none';
            document.getElementById('levelDisplay').style.display = 'none';
            document.getElementById('playerWelcome').style.display = 'none';
            
            // Remove player from live scoreboard
            if (currentPlayerId) {
                removePlayerFromLiveScoreboard(currentPlayerId);
                currentPlayerId = null;
            }
            
            // Ensure food is properly reset
            generateFood();
            if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
                console.log('CRITICAL: Food object invalid after restart, creating emergency food');
                food = {x: 15, y: 15}; // Emergency fallback
                generateFood(); // Try one more time
            }
            
            // Stop the current game loop
            if (gameInterval) {
                clearInterval(gameInterval);
            }
        }

        function changeDirection(direction) {
            if (!gameRunning) return;
            
            switch(direction) {
                case 'ArrowUp':
                    if (dy !== 1) { dx = 0; dy = -1; }
                    break;
                case 'ArrowDown':
                    if (dy !== -1) { dx = 0; dy = 1; }
                    break;
                case 'ArrowLeft':
                    if (dx !== 1) { dx = -1; dy = 0; }
                    break;
                case 'ArrowRight':
                    if (dx !== -1) { dx = 1; dy = 0; }
                    break;
            }
        }

        function gameLoop() {
            if (gameRunning) {
                // AGGRESSIVE FOOD VALIDATION: Check food validity and bounds every frame
                if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
                    console.log('üö® GAME LOOP: Food is invalid, regenerating immediately...');
                    generateFood();
                } else {
                    // Check if food is outside valid bounds
                    if (food.x < 0 || food.x >= 32 || food.y < 0 || food.y >= 24) {
                        console.log('üö® GAME LOOP: Food outside bounds at', food.x, food.y, '- regenerating...');
                        generateFood();
                    } else {
                        // Check if food is on snake
                        let foodOnSnake = false;
                        for (let segment of snake) {
                            if (segment.x === food.x && segment.y === food.y) {
                                foodOnSnake = true;
                                console.log('üö® GAME LOOP: Food on snake detected, regenerating...');
                                break;
                            }
                        }
                        if (foodOnSnake) {
                            generateFood();
                        }
                    }
                }
                
                // Additional safety check using force regeneration
                forceFoodRegeneration();
                
                moveSnake();
                drawGame();
                
                // Debug: log food position during gameplay
                if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                    console.log('Game loop - Food at:', food.x, food.y);
                }
            } else {
                // Draw the initial game state when not running
                drawGame();
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            changeDirection(e.key);
        });

        // Add roundRect polyfill for older browsers
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
                this.closePath();
            };
        }

        // Google OAuth Configuration
        const GOOGLE_CLIENT_ID = 'YOUR_GOOGLE_CLIENT_ID'; // Replace with your actual Google Client ID
        const GOOGLE_REDIRECT_URI = window.location.origin + window.location.pathname;
        
        // Load Google OAuth script (disabled for demo)
        function loadGoogleOAuth() {
            // Skip Google OAuth loading for demo purposes
            console.log('Google OAuth loading skipped (demo mode)');
        }
        
        // Initialize Google OAuth
        function initializeGoogleOAuth() {
            try {
                if (typeof google !== 'undefined' && google.accounts) {
                    // For demo purposes, we'll skip the actual Google OAuth setup
                    console.log('Google OAuth would be initialized here in production');
                }
            } catch (error) {
                console.log('Google OAuth initialization skipped (demo mode)');
            }
        }
        
        // Handle Google Sign In
        function handleGoogleSignIn(response) {
            try {
                const payload = JSON.parse(atob(response.credential.split('.')[1]));
                const playerName = payload.name || payload.given_name || 'Google User';
                const playerEmail = payload.email;
                
                // Store player info
                localStorage.setItem('snakePlayerName', playerName);
                localStorage.setItem('snakePlayerEmail', playerEmail);
                
                // Update the player name input
                document.getElementById('playerName').value = playerName;
                
                // Show success message
                alert(`Welcome, ${playerName}! You can now start playing.`);
                
                console.log('Google login successful:', { name: playerName, email: playerEmail });
            } catch (error) {
                console.error('Error processing Google sign-in:', error);
                alert('Google login failed. Please try again or enter your name manually.');
            }
        }
        
        // Manual Google login function (fallback)
        function loginWithGoogle() {
            if (typeof google !== 'undefined' && google.accounts) {
                google.accounts.id.prompt();
            } else {
                // Fallback: simulate Google login for demo purposes
                const demoName = 'Demo User';
                document.getElementById('playerName').value = demoName;
                localStorage.setItem('snakePlayerName', demoName);
                alert(`Demo mode: Welcome, ${demoName}! You can now start playing.`);
            }
        }
        
        // Get player name from input or stored value
        function getPlayerName() {
            const inputName = document.getElementById('playerName').value.trim();
            const storedName = localStorage.getItem('snakePlayerName');
            return inputName || storedName || 'Player';
        }
        
        // Player name validation function
        function validatePlayerName() {
            const playerName = getPlayerName();
            if (!playerName || playerName === 'Player') {
                alert('Please enter your name before starting the game!');
                return false;
            }
            return true;
        }

        // Live Score Card System
        let livePlayers = new Map(); // Store active players
        let currentPlayerId = null;
        let scoreUpdateInterval = null;

        // Generate unique player ID
        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Add player to live scoreboard
        function addPlayerToLiveScoreboard(playerName) {
            const playerId = generatePlayerId();
            currentPlayerId = playerId;
            
            const playerData = {
                id: playerId,
                name: playerName,
                score: 0,
                level: '',
                startTime: Date.now(),
                lastUpdate: Date.now()
            };
            
            livePlayers.set(playerId, playerData);
            updateLiveScoreboard();
            
            // Start score update interval for this player
            startScoreUpdates();
            
            console.log('Player added to live scoreboard:', playerData);
            return playerId;
        }

        // Update player score in live scoreboard
        function updatePlayerScore(playerId, newScore, level = '') {
            if (livePlayers.has(playerId)) {
                const player = livePlayers.get(playerId);
                player.score = newScore;
                player.level = level;
                player.lastUpdate = Date.now();
                livePlayers.set(playerId, player);
                
                // Update the scoreboard
                updateLiveScoreboard();
            }
        }

        // Remove player from live scoreboard
        function removePlayerFromLiveScoreboard(playerId) {
            if (livePlayers.has(playerId)) {
                livePlayers.delete(playerId);
                updateLiveScoreboard();
                console.log('Player removed from live scoreboard:', playerId);
            }
        }

        // Update the live scoreboard display
        function updateLiveScoreboard() {
            const scoreList = document.getElementById('scoreList');
            const playerCount = document.getElementById('playerCount');
            
            if (!scoreList) return;
            
            // Convert Map to array and sort by score (highest first)
            const sortedPlayers = Array.from(livePlayers.values())
                .sort((a, b) => b.score - a.score);
            
            // Update player count
            playerCount.textContent = `${sortedPlayers.length} player${sortedPlayers.length !== 1 ? 's' : ''} online`;
            
            if (sortedPlayers.length === 0) {
                scoreList.innerHTML = '<div class="no-scores">No players currently online</div>';
                return;
            }
            
            // Generate score list HTML
            let scoreHTML = '';
            sortedPlayers.forEach((player, index) => {
                const rank = index + 1;
                const rankClass = rank <= 3 ? `rank-${rank}` : '';
                const currentPlayerClass = player.id === currentPlayerId ? 'current-player' : '';
                
                scoreHTML += `
                    <div class="score-item ${rankClass} ${currentPlayerClass}">
                        <div class="player-info">
                            <span class="player-rank">#${rank}</span>
                            <span class="player-name" title="${player.name}">${player.name}</span>
                        </div>
                        <div class="player-score">${player.score}</div>
                    </div>
                `;
            });
            
            scoreList.innerHTML = scoreHTML;
        }

        // Start periodic score updates
        function startScoreUpdates() {
            if (scoreUpdateInterval) {
                clearInterval(scoreUpdateInterval);
            }
            
            scoreUpdateInterval = setInterval(() => {
                if (currentPlayerId && livePlayers.has(currentPlayerId)) {
                    const player = livePlayers.get(currentPlayerId);
                    // Update score if game is running
                    if (gameRunning) {
                        updatePlayerScore(currentPlayerId, score, currentLevel);
                    }
                }
                
                // Clean up inactive players (not updated in last 5 minutes)
                const now = Date.now();
                const inactiveThreshold = 5 * 60 * 1000; // 5 minutes
                
                for (const [playerId, player] of livePlayers.entries()) {
                    if (now - player.lastUpdate > inactiveThreshold) {
                        livePlayers.delete(playerId);
                    }
                }
                
                updateLiveScoreboard();
                
                        // FOOD HEALTH CHECK: Ensure food is always valid
        if (gameRunning && (!food || typeof food.x !== 'number' || typeof food.y !== 'number')) {
            console.log('üö® PERIODIC CHECK: Food is invalid, regenerating...');
            generateFood();
            console.log('Food regenerated during health check:', food);
            lastFoodTime = Date.now(); // Reset timer
        }
        
        // AGGRESSIVE FOOD MONITORING: Check every frame
        if (gameRunning && food && typeof food.x === 'number' && typeof food.y === 'number') {
            // Verify food is still valid and not on snake
            let foodStillValid = true;
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    console.log('üö® FOOD ON SNAKE DETECTED! Regenerating...');
                    foodStillValid = false;
                    break;
                }
            }
            if (!foodStillValid) {
                generateFood();
                console.log('Food regenerated due to snake collision:', food);
                lastFoodTime = Date.now(); // Reset timer
            } else {
                // Food is valid, update timer
                lastFoodTime = Date.now();
            }
        }
        
        // TIME-BASED FOOD MONITORING: Force regeneration if food has been missing too long
        if (gameRunning && (Date.now() - lastFoodTime > foodMissingThreshold)) {
            console.log('‚è∞ TIME-BASED CHECK: Food missing for too long, forcing regeneration...');
            generateFood();
            lastFoodTime = Date.now();
        }
        
        // TILE COUNT VALIDATION: Ensure tile count is always valid
        if (gameRunning && (!tileCount || tileCount <= 0 || tileCount > 100)) {
            console.log('üö® TILE COUNT VALIDATION: Invalid tile count detected:', tileCount);
            tileCount = 32; // Reset to fixed value
            if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
                console.log('üîÑ Regenerating food after tile count fix...');
                generateFood();
            }
        }
            }, 1000); // Update every 1 second for more frequent food monitoring
        }

        // Refresh live scores manually
        function refreshLiveScores() {
            updateLiveScoreboard();
            console.log('Live scores refreshed manually');
        }
        
        // Update food debug display
        function updateFoodDebug() {
            const foodDebugElement = document.getElementById('foodDebug');
            const foodCoordsElement = document.getElementById('foodCoords');
            const gridInfoElement = document.getElementById('gridInfo');
            
            if (food && typeof food.x === 'number' && typeof food.y === 'number') {
                foodCoordsElement.textContent = `(${food.x}, ${food.y})`;
                foodDebugElement.style.display = 'block';
            } else {
                foodCoordsElement.textContent = 'INVALID';
                foodDebugElement.style.display = 'block';
            }
            
            // Show grid information with correct dimensions - ALWAYS USE FIXED VALUES
            if (gridInfoElement) {
                gridInfoElement.textContent = `32x24 (768 tiles)`;
            }
        }
        
        // Fixed tile count for consistent gameplay
        // Canvas: 800x600, Grid: 25x25, Tiles: 32x24
        
        // Draw test pattern to verify canvas is working
        function drawTestPattern() {
            console.log('üß™ Drawing test pattern to verify canvas...');
            
            // Draw a bright blue square in top-left corner
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(0, 0, 50, 50);
            console.log('‚úÖ Blue test square drawn at (0,0)');
            
            // Draw a bright green circle in top-right corner
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(canvas.width - 25, 25, 25, 0, 2 * Math.PI);
            ctx.fill();
            console.log('‚úÖ Green test circle drawn at top-right');
            
            // Draw a bright red triangle in bottom-left corner
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 50);
            ctx.lineTo(50, canvas.height);
            ctx.lineTo(50, canvas.height - 50);
            ctx.closePath();
            ctx.fill();
            console.log('‚úÖ Red test triangle drawn at bottom-left');
        }
        
        // Global debug grid toggle
        let debugGridEnabled = false;
        
        // Draw visual grid for debugging
        function drawDebugGrid() {
            if (!debugGridEnabled) return;
            
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            
            // Draw vertical lines every 25 pixels
            for (let x = 0; x <= canvas.width; x += 25) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal lines every 25 pixels
            for (let y = 0; y <= canvas.height; y += 25) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            console.log('Debug grid drawn');
        }
        
        // Toggle debug grid on/off
        function toggleDebugGrid() {
            debugGridEnabled = !debugGridEnabled;
            console.log('Debug grid toggled:', debugGridEnabled ? 'ON' : 'OFF');
            drawGame(); // Redraw to show/hide grid
        }
        
        // Force food regeneration if needed
        function forceFoodRegeneration() {
            if (!food || typeof food.x !== 'number' || typeof food.y !== 'number') {
                console.log('üîÑ FORCE REGENERATION: Food is invalid, regenerating...');
                generateFood();
                return true;
            }
            
            // Check if food is outside valid bounds
            if (food.x < 0 || food.x >= 32 || food.y < 0 || food.y >= 24) {
                console.log('üîÑ FORCE REGENERATION: Food outside bounds at', food.x, food.y, '- regenerating...');
                generateFood();
                return true;
            }
            
            // Check if food is on snake
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    console.log('üîÑ FORCE REGENERATION: Food on snake, regenerating...');
                    generateFood();
                    return true;
                }
            }
            
            return false;
        }
        
        // Initialize game when page is fully loaded
        window.addEventListener('load', function() {
            console.log('Page loaded, initializing game...');
            
            // Check for stored player name
            const storedName = localStorage.getItem('snakePlayerName');
            if (storedName) {
                document.getElementById('playerName').value = storedName;
                console.log('Restored player name:', storedName);
            }
            
            // Debug: Check if elements exist
            const playerNameInput = document.getElementById('playerName');
            console.log('Player name input found:', !!playerNameInput);
            
            // Initialize game components
            try {
                // Use fixed tile count for consistent gameplay
                tileCount = 32; // Fixed value for 800x600 canvas
                console.log('Initial tile count:', tileCount);
                
                generateFood(); // Generate initial food
                console.log('Initial food position:', food);
                
                // Draw initial game state
                drawGame();
                console.log('Initial game state drawn');
                
                // Start the game loop
                gameInterval = setInterval(gameLoop, gameSpeed);
                console.log('Game loop started with speed:', gameSpeed, 'ms');
                
                // Load Google OAuth
                loadGoogleOAuth();
                
                // Add demo players
                setTimeout(() => {
                    addDemoPlayers();
                }, 1000);
                
            } catch (error) {
                console.error('Error initializing game:', error);
            }
        });

    </script>
</body>
</html>

